name: 构建全量Linux发行版arm64 RootFS

on:
  push:
    branches: [ main ]
    paths: [ '.github/workflows/build-all-arm64-rootfs.yml' ]  # 仅该文件变更时触发
  workflow_dispatch:
    inputs:
      debug_mode:
        description: "启用调试模式（保留临时文件，便于排错）"
        type: boolean
        default: false

jobs:
  build-arm64-rootfs:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # 单个发行版失败不阻断其他构建
      matrix:
        include:
          # Debian系（统一用debootstrap）
          - name: debian
            type: debian-like
            release: bookworm
            mirror: "http://mirrors.ustc.edu.cn/debian-ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/debian-ports/archive-key.gpg"
          - name: ubuntu
            type: debian-like
            release: jammy
            mirror: "http://mirrors.ustc.edu.cn/ubuntu-ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/ubuntu-ports/archive-key-2025.gpg"  # 补充Ubuntu GPG密钥
          - name: deepin
            type: debian-like
            release: apricot
            mirror: "http://mirrors.ustc.edu.cn/deepin-ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/deepin-ports/archive-key.gpg"
          - name: openkylin
            type: debian-like
            release: 1.0
            mirror: "http://mirrors.ustc.edu.cn/openkylin/ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/openkylin/ports/archive-key.gpg"
          - name: kali
            type: debian-like
            release: kali-rolling
            mirror: "http://mirrors.ustc.edu.cn/kali-ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/kali-ports/archive-key.asc"
          - name: parrot
            type: debian-like
            release: rolling
            mirror: "http://mirrors.ustc.edu.cn/parrot-ports/"
            gpg_key: "https://mirrors.ustc.edu.cn/parrot-ports/archive-key.asc"
          - name: backbox
            type: debian-like
            release: 7
            mirror: "http://mirrors.ustc.edu.cn/backbox-ports/7/"
            gpg_key: "https://mirrors.ustc.edu.cn/backbox-ports/archive-key.asc"
          # Arch系（统一用pacstrap/basestrap）
          - name: arch
            type: arch-like
            release: aarch64
            mirror: "https://mirrors.tuna.tsinghua.edu.cn/archlinuxarm/$repo/$arch"
            gpg_key: ""  # ArchARM密钥通过pacman-key --populate自动导入
          - name: manjaro
            type: arch-like
            release: aarch64-unstable
            mirror: "https://mirrors.tuna.tsinghua.edu.cn/manjaro-arm/$repo/$arch"
            gpg_key: ""
          - name: artix
            type: arch-like
            release: aarch64
            mirror: "https://mirrors.tuna.tsinghua.edu.cn/artix-linux/$repo/$arch"
            gpg_key: ""
          # RHEL/Fedora系（统一用dnf）
          - name: fedora
            type: rhel-like
            release: 40
            mirror: "http://mirrors.ustc.edu.cn/fedora-secondary/releases/$release/Everything/aarch64/os/"
            gpg_key: "https://getfedora.org/static/fedora.gpg"
          - name: centos_stream
            type: rhel-like
            release: 9
            mirror: "http://mirrors.ustc.edu.cn/centos-stream/$release-stream/BaseOS/aarch64/os/"
            gpg_key: "https://mirrors.ustc.edu.cn/centos-stream/RPM-GPG-KEY-CentOS-Stream-9"
          - name: rocky
            type: rhel-like
            release: 9
            mirror: "http://mirrors.ustc.edu.cn/rocky/$release/BaseOS/aarch64/os/"
            gpg_key: "https://mirrors.ustc.edu.cn/rocky/RPM-GPG-KEY-rockyofficial"
          # SUSE系（zypper）
          - name: opensuse
            type: suse-like
            release: tumbleweed
            mirror: "http://mirrors.ustc.edu.cn/opensuse/ports/tumbleweed/repo/oss/aarch64/"
            gpg_key: "https://mirrors.ustc.edu.cn/opensuse/ports/tumbleweed/repo/oss/aarch64/repodata/repomd.xml.key"
          # Alpine系（alpine-make-rootfs/apk）
          - name: alpine
            type: alpine-like
            release: 3.20
            mirror: "http://mirrors.tuna.tsinghua.edu.cn/alpine/v$release/main/"  # 修复Alpine镜像路径（需指定main仓库）
            gpg_key: ""
          - name: adelie
            type: alpine-like
            release: 1.0
            mirror: "http://mirrors.ustc.edu.cn/adelie/os/aarch64/main/"
            gpg_key: "https://adelielinux.org/keys/adelie-devel.asc"
          # 独立系
          - name: void
            type: void-like
            release: current
            mirror: "https://mirrors.tuna.tsinghua.edu.cn/voidlinux/current/aarch64/"
            gpg_key: "https://mirrors.tuna.tsinghua.edu.cn/voidlinux/void-release-20240120.pub"
          - name: pardus
            type: pardus-like
            release: 23
            mirror: "http://mirrors.ustc.edu.cn/pardus-archive/23/aarch64/main/"
            gpg_key: "https://pardus.org.tr/keys/pardus-23.gpg"
          - name: chimera
            type: chimera-like
            release: 1.0
            mirror: "http://mirrors.ustc.edu.cn/chimeraos/repo/aarch64/"
            gpg_key: "https://chimeraos.org/gpg.pub"
          - name: gentoo
            type: gentoo-like
            release: stage3
            mirror: "http://mirrors.ustc.edu.cn/gentoo/releases/aarch64/autobuilds/current-stage3-arm64-desktop-systemd/"
            gpg_key: ""

    steps:
      # 1. 检出代码（固定v4版本，确保稳定性）
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1  # 仅拉取最新提交，减少耗时

      # 2. 安装核心依赖（修复Ubuntu无xbps-install的问题，补充关键工具）
      - name: Install core dependencies
        run: |
          set -euo pipefail
          # 优先使用ustc镜像加速APT
          sudo sed -i 's@http://archive.ubuntu.com/ubuntu/@http://mirrors.ustc.edu.cn/ubuntu/@g' /etc/apt/sources.list
          sudo apt update -y || { echo "❌ APT更新失败（检查网络或镜像）"; exit 1; }
          
          # 安装基础依赖（移除xbps-install，Ubuntu源无此包，后续手动下载）
          sudo apt install -y \
            debootstrap arch-install-scripts basestrap \
            xz-utils tar gzip wget curl \
            qemu-user-static binfmt-support \
            dnf zypper || { echo "❌ 核心依赖安装失败"; exit 1; }
          
          # 手动下载Void的xbps-install（解决Ubuntu无xbps-install的问题）
          sudo wget -O /usr/bin/xbps-install \
            https://mirrors.tuna.tsinghua.edu.cn/voidlinux/current/aarch64/static/xbps-install.static \
            || { echo "❌ xbps-install下载失败"; exit 1; }
          sudo chmod +x /usr/bin/xbps-install
          
          # 注册QEMU-aarch64模拟（必须步骤，否则无法chroot到arm64环境）
          sudo update-binfmts --enable qemu-aarch64 || { echo "❌ QEMU-aarch64注册失败"; exit 1; }
          echo "✅ 核心依赖安装完成"

      # 3. 初始化构建环境（统一日期格式，创建安全路径）
      - name: Init build env
        run: |
          set -euo pipefail
          # 用GitHub内置时间生成8位日期（YYYYMMdd），确保产物名唯一
          DATE_STR="${{ format('{0:YYYYMMdd}', github.run_started_at) }}"
          # 产物名格式：发行版-版本-架构-日期.rootfs.xz（清晰易区分）
          ROOTFS_NAME="${{ matrix.name }}-${{ matrix.release }}-arm64-${DATE_STR}.rootfs.xz"
          # 挂载目录用/tmp（避免/mnt权限问题），添加随机后缀防止冲突
          ROOTFS_MOUNT="/tmp/arm64-rootfs-${{ matrix.name }}-$RANDOM"
          
          # 写入环境变量供后续步骤使用
          echo "ROOTFS_NAME=$ROOTFS_NAME" >> "$GITHUB_ENV"
          echo "ROOTFS_MOUNT=$ROOTFS_MOUNT" >> "$GITHUB_ENV"
          
          # 创建挂载目录并设置权限
          sudo mkdir -p "$ROOTFS_MOUNT" || { echo "❌ 挂载目录创建失败"; exit 1; }
          sudo chmod 755 "$ROOTFS_MOUNT" || { echo "❌ 挂载目录权限设置失败"; exit 1; }
          
          echo "✅ 构建环境初始化完成"
          echo "  - 产物名：$ROOTFS_NAME"
          echo "  - 挂载目录：$ROOTFS_MOUNT"

      # 4. 生成构建脚本（修复多发行版逻辑漏洞，补充关键初始化步骤）
      - name: Generate build script
        run: |
          set -euo pipefail
          cat > build.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail  # 严格模式：错误/未定义变量/管道失败均退出
          ROOTFS_NAME="$1"
          ROOTFS_MOUNT="$2"
          # 从矩阵变量注入构建参数
          DISTRO_NAME="${{ matrix.name }}"
          DISTRO_TYPE="${{ matrix.type }}"
          DISTRO_RELEASE="${{ matrix.release }}"
          DISTRO_MIRROR="${{ matrix.mirror }}"
          DISTRO_GPG="${{ matrix.gpg_key }}"
          DEBUG_MODE="${{ github.event.inputs.debug_mode }}"

          # -------------------------- 通用工具函数 --------------------------
          # 错误处理：输出提示并清理环境
          error_exit() {
            echo -e "\033[31m❌ $1\033[0m"
            if [ "$DEBUG_MODE" = "false" ]; then
              # 强制卸载挂载点（避免占用）
              sudo umount -l "$ROOTFS_MOUNT" 2>/dev/null || true
              sudo rm -rf "$ROOTFS_MOUNT"
            fi
            exit 1
          }

          # GPG密钥导入（仅当密钥存在时执行）
          import_gpg() {
            if [ -n "$1" ] && [ "$1" != "null" ]; then
              echo "🔑 导入GPG密钥：$1"
              sudo curl -fsSL "$1" -o /tmp/distro.gpg || error_exit "GPG密钥下载失败"
              # 分发行版处理GPG密钥（Debian系用apt信任，RPM系用rpm导入）
              if [[ "$DISTRO_TYPE" =~ "debian-like" || "$DISTRO_TYPE" =~ "alpine-like" ]]; then
                sudo gpg --dearmor -o "/etc/apt/trusted.gpg.d/${DISTRO_NAME}.gpg" /tmp/distro.gpg \
                  || error_exit "GPG密钥转换失败（Debian/Alpine系）"
              else
                sudo rpm --import /tmp/distro.gpg || error_exit "GPG密钥导入失败（RPM系）"
              fi
            fi
          }

          # -------------------------- Debian系构建（修复密钥信任问题） --------------------------
          if [ "$DISTRO_TYPE" = "debian-like" ]; then
            echo "🚀 开始构建 Debian系：$DISTRO_NAME $DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 执行debootstrap第一阶段（仅下载包，不执行配置）
            sudo debootstrap --arch=arm64 --foreign "$DISTRO_RELEASE" "$ROOTFS_MOUNT" "$DISTRO_MIRROR" \
              || error_exit "debootstrap第一阶段失败（检查镜像是否支持arm64）"
            
            # 复制QEMU解释器（chroot必需）
            sudo cp /usr/bin/qemu-aarch64-static "$ROOTFS_MOUNT/usr/bin/" \
              || error_exit "QEMU-aarch64复制失败"
            
            # 执行debootstrap第二阶段（配置系统）
            sudo chroot "$ROOTFS_MOUNT" /debootstrap/debootstrap --second-stage \
              || error_exit "debootstrap第二阶段失败（QEMU模拟异常）"
            
            # 清理APT缓存（减少产物体积）
            sudo chroot "$ROOTFS_MOUNT" apt clean || error_exit "APT缓存清理失败"
            sudo rm -rf "$ROOTFS_MOUNT/var/lib/apt/lists/*" || true
          fi

          # -------------------------- Arch系构建（修复密钥初始化问题） --------------------------
          if [ "$DISTRO_TYPE" = "arch-like" ]; then
            echo "🚀 开始构建 Arch系：$DISTRO_NAME $DISTRO_RELEASE (arm64)"
            # 配置镜像源（Arch系需指定$repo/$arch变量）
            echo "Server = $DISTRO_MIRROR" | sudo tee /etc/pacman.d/mirrorlist \
              || error_exit "镜像源配置失败"
            
            # 初始化Pacman密钥环
            sudo pacman-key --init || error_exit "Pacman密钥环初始化失败"
            if [ "$DISTRO_NAME" = "artix" ]; then
              sudo pacman-key --populate artix || error_exit "Artix密钥导入失败"
            else
              sudo pacman-key --populate archlinuxarm || error_exit "ArchARM密钥导入失败"
            fi
            
            # 安装基础系统（Artix用basestrap，其他用pacstrap）
            if [ "$DISTRO_NAME" = "artix" ]; then
              sudo basestrap -C /etc/pacman.conf -K --arch=aarch64 "$ROOTFS_MOUNT" base \
                || error_exit "basestrap构建失败"
            else
              sudo pacstrap -C /etc/pacman.conf -K --arch=aarch64 "$ROOTFS_MOUNT" base \
                || error_exit "pacstrap构建失败"
            fi
            
            # 清理Pacman缓存
            sudo chroot "$ROOTFS_MOUNT" pacman -Scc --noconfirm || error_exit "Pacman缓存清理失败"
          fi

          # -------------------------- RHEL系构建（修复DNF架构指定问题） --------------------------
          if [ "$DISTRO_TYPE" = "rhel-like" ]; then
            echo "🚀 开始构建 RHEL系：$DISTRO_NAME $DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 配置DNF源（区分Fedora和其他RHEL系）
            if [ "$DISTRO_NAME" = "fedora" ]; then
              sudo tee "$ROOTFS_MOUNT/etc/yum.repos.d/fedora.repo" << EOF_REPO
              [fedora]
              name=Fedora $DISTRO_RELEASE - aarch64
              baseurl=$DISTRO_MIRROR
              gpgcheck=1
              gpgkey=$DISTRO_GPG
              EOF_REPO
            else
              sudo tee "$ROOTFS_MOUNT/etc/yum.repos.d/${DISTRO_NAME}.repo" << EOF_REPO
              [baseos]
              name=${DISTRO_NAME^} $DISTRO_RELEASE - BaseOS (aarch64)
              baseurl=$DISTRO_MIRROR
              gpgcheck=1
              gpgkey=$DISTRO_GPG
              EOF_REPO
            fi
            
            # 安装基础系统（强制指定aarch64架构）
            sudo dnf --installroot="$ROOTFS_MOUNT" --releasever="$DISTRO_RELEASE" \
              --forcearch=aarch64 --nogpgcheck install -y basesystem \
              || error_exit "DNF构建失败（--nogpgcheck临时规避密钥信任问题）"
            
            # 清理DNF缓存
            sudo dnf --installroot="$ROOTFS_MOUNT" clean all || error_exit "DNF缓存清理失败"
          fi

          # -------------------------- SUSE系构建（修复RPM数据库初始化问题） --------------------------
          if [ "$DISTRO_TYPE" = "suse-like" ]; then
            echo "🚀 开始构建 SUSE系：$DISTRO_NAME $DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 初始化RPM数据库（zypper必需步骤）
            sudo rpm --root "$ROOTFS_MOUNT" --initdb || error_exit "RPM数据库初始化失败"
            
            # 添加ZYPPER源并刷新
            sudo zypper addrepo -f -n "OpenSUSE $DISTRO_RELEASE" "$DISTRO_MIRROR" opensuse-repo \
              || error_exit "ZYPPER源添加失败"
            sudo zypper --installroot="$ROOTFS_MOUNT" refresh || error_exit "ZYPPER源刷新失败"
            
            # 安装基础系统（--no-recommends减少冗余包）
            sudo zypper --installroot="$ROOTFS_MOUNT" --arch=aarch64 \
              install -y --no-recommends patterns-base-base \
              || error_exit "ZYPPER构建失败"
            
            # 清理ZYPPER缓存
            sudo zypper --installroot="$ROOTFS_MOUNT" clean -a || error_exit "ZYPPER缓存清理失败"
          fi

          # -------------------------- Alpine系构建（修复镜像路径+密钥问题） --------------------------
          if [ "$DISTRO_TYPE" = "alpine-like" ]; then
            echo "🚀 开始构建 Alpine系：$DISTRO_NAME $DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 下载Alpine官方构建工具
            wget -O /tmp/alpine-make-rootfs \
              https://raw.githubusercontent.com/alpinelinux/alpine-make-rootfs/master/alpine-make-rootfs \
              || error_exit "Alpine构建工具下载失败"
            chmod +x /tmp/alpine-make-rootfs
            
            # 构建RootFS（Adelie需额外指定密钥）
            if [ "$DISTRO_NAME" = "adelie" ]; then
              sudo /tmp/alpine-make-rootfs -a aarch64 -s "$DISTRO_MIRROR" \
                -k "$DISTRO_GPG" "$ROOTFS_NAME" "$DISTRO_RELEASE" \
                || error_exit "Adelie构建失败"
            else
              sudo /tmp/alpine-make-rootfs -a aarch64 -s "$DISTRO_MIRROR" \
                "$ROOTFS_NAME" "$DISTRO_RELEASE" \
                || error_exit "Alpine构建失败"
            fi
            
            echo "✅ $DISTRO_NAME 构建完成（自动压缩为xz格式）"
            exit 0  # 跳过后续统一压缩步骤
          fi

          # -------------------------- Void构建（修复架构指定+依赖问题） --------------------------
          if [ "$DISTRO_TYPE" = "void-like" ]; then
            echo "🚀 开始构建 Void：$DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 安装基础系统（强制指定aarch64架构，避免x86_64包）
            sudo xbps-install -S -r "$ROOTFS_MOUNT" -R "$DISTRO_MIRROR" \
              --arch=aarch64 base-system \
              || error_exit "xbps-install构建失败"
            
            # 清理XBPS缓存
            sudo xbps-remove -r "$ROOTFS_MOUNT" -O || error_exit "Void缓存清理失败"
          fi

          # -------------------------- Pardus构建（复用Debian逻辑，补充源配置） --------------------------
          if [ "$DISTRO_TYPE" = "pardus-like" ]; then
            echo "🚀 开始构建 Pardus：$DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 配置APT源
            sudo tee "$ROOTFS_MOUNT/etc/apt/sources.list" << EOF_REPO
            deb $DISTRO_MIRROR /
            EOF_REPO
            
            # 执行debootstrap（同Debian系）
            sudo debootstrap --arch=arm64 --foreign "$DISTRO_RELEASE" "$ROOTFS_MOUNT" "$DISTRO_MIRROR" \
              || error_exit "Pardus debootstrap第一阶段失败"
            sudo cp /usr/bin/qemu-aarch64-static "$ROOTFS_MOUNT/usr/bin/" \
              || error_exit "QEMU复制失败"
            sudo chroot "$ROOTFS_MOUNT" /debootstrap/debootstrap --second-stage \
              || error_exit "Pardus debootstrap第二阶段失败"
            
            # 清理APT缓存
            sudo chroot "$ROOTFS_MOUNT" apt clean || error_exit "Pardus APT清理失败"
          fi

          # -------------------------- Chimera构建（修复APK数据库初始化问题） --------------------------
          if [ "$DISTRO_TYPE" = "chimera-like" ]; then
            echo "🚀 开始构建 Chimera：$DISTRO_RELEASE (arm64)"
            import_gpg "$DISTRO_GPG"
            
            # 初始化APK数据库（Chimera基于apk，必需步骤）
            sudo apk --root "$ROOTFS_MOUNT" add --initdb || error_exit "APK数据库初始化失败"
            
            # 配置APK源
            sudo mkdir -p "$ROOTFS_MOUNT/etc/apk"
            sudo tee "$ROOTFS_MOUNT/etc/apk/repositories" << EOF_REPO
            $DISTRO_MIRROR
            EOF_REPO
            
            # 安装基础系统
            sudo apk --root "$ROOTFS_MOUNT" --arch aarch64 add base \
              || error_exit "Chimera APK安装失败"
            
            # 清理APK缓存
            sudo apk --root "$ROOTFS_MOUNT" cache clean || error_exit "Chimera APK清理失败"
          fi

          # -------------------------- Gentoo构建（修复Stage3下载正则+权限问题） --------------------------
          if [ "$DISTRO_TYPE" = "gentoo-like" ]; then
            echo "🚀 开始构建 Gentoo：$DISTRO_RELEASE (arm64)"
            # 下载最新Stage3镜像（正则匹配准确的文件名）
            STAGE3_URL=$(curl -fsSL "$DISTRO_MIRROR" | \
              grep -oE 'href="stage3-arm64-desktop-systemd-[0-9]{8}-[0-9]+\.tar\.xz"' | \
              head -n1 | sed 's/href="//;s/"//')
            [ -z "$STAGE3_URL" ] && error_exit "未找到Gentoo Stage3 aarch64镜像（检查镜像地址）"
            
            # 下载并解压Stage3
            sudo wget -O /tmp/gentoo-stage3.tar.xz "$DISTRO_MIRROR/$STAGE3_URL" \
              || error_exit "Gentoo Stage3下载失败"
            sudo tar -xJf /tmp/gentoo-stage3.tar.xz -C "$ROOTFS_MOUNT" \
              || error_exit "Gentoo Stage3解压失败"
            
            # 配置Gentoo编译参数
            sudo tee "$ROOTFS_MOUNT/etc/portage/make.conf" << EOF
            CHOST="aarch64-unknown-linux-gnu"
            ARCH="arm64"
            MAKEOPTS="-j\$(nproc)"  # 自动适配CPU核心数
            EOF
          fi

          # -------------------------- 统一压缩RootFS（除Alpine系外） --------------------------
          echo "📦 压缩RootFS产物（xz格式，高压缩率）..."
          sudo tar -cJf "$ROOTFS_NAME" -C "$ROOTFS_MOUNT" . \
            || error_exit "RootFS压缩失败（检查磁盘空间）"
          # 修正产物权限（确保GitHub Actions可读取）
          sudo chown "$USER:$USER" "$ROOTFS_NAME" || error_exit "产物权限修正失败"

          # -------------------------- 清理环境（调试模式除外） --------------------------
          if [ "$DEBUG_MODE" = "false" ]; then
            sudo umount -l "$ROOTFS_MOUNT" 2>/dev/null || true
            sudo rm -rf "$ROOTFS_MOUNT" /tmp/*.gpg /tmp/gentoo-stage3.tar.xz /tmp/alpine-make-rootfs
          fi

          echo -e "\033[32m✅ $DISTRO_NAME $DISTRO_RELEASE (arm64) 构建完成！产物：$ROOTFS_NAME\033[0m"
          EOF
          # 赋予脚本执行权限
          chmod +x build.sh || { echo "❌ 构建脚本权限设置失败"; exit 1; }
          echo "✅ 构建脚本生成完成"

      # 5. 执行构建（捕获错误并输出详细日志）
      - name: Build arm64 RootFS
        run: |
          set -euo pipefail
          # 打印构建脚本内容（便于排错）
          echo "📄 构建脚本内容："
          cat build.sh
          echo -e "\n🚀 开始执行构建..."
          # 执行构建（失败时输出明确提示）
          ./build.sh "${{ env.ROOTFS_NAME }}" "${{ env.ROOTFS_MOUNT }}" || {
            echo -e "\033[31m❌ ${{ matrix.name }} 构建失败！查看上方日志排查以下问题：\033[0m"
            echo "  1. 镜像源是否支持arm64架构"
            echo "  2. GPG密钥是否有效（可尝试--nogpgcheck临时规避）"
            echo "  3. 磁盘空间是否充足（ubuntu-latest默认14GB）"
            exit 1
          }

      # 6. 验证产物有效性（排除空文件/损坏文件）
      - name: Validate RootFS
        run: |
          set -euo pipefail
          ROOTFS_PATH="./${{ env.ROOTFS_NAME }}"
          # 检查文件是否存在
          [ -f "$ROOTFS_PATH" ] || { echo -e "\033[31m❌ 产物文件不存在\033[0m"; exit 1; }
          # 检查文件大小（小于10MB视为无效，排除空产物）
          MIN_SIZE=$((10 * 1024 * 1024))  # 10MB
          FILE_SIZE=$(stat -c%s "$ROOTFS_PATH")
          if [ "$FILE_SIZE" -lt "$MIN_SIZE" ]; then
            echo -e "\033[31m❌ 产物无效（大小：$(du -sh "$ROOTFS_PATH" | awk '{print $1}') < 10MB）\033[0m"
            exit 1
          fi
          # 检查文件完整性（尝试解压测试）
          echo "🔍 测试产物完整性（解压前100KB验证）..."
          head -c 102400 "$ROOTFS_PATH" | xz -t >/dev/null 2>&1 || {
            echo -e "\033[31m❌ 产物损坏（xz解压验证失败）\033[0m"
            exit 1
          }
          echo -e "\033[32m✅ 产物验证通过！\033[0m"
          echo "  - 路径：$ROOTFS_PATH"
          echo "  - 大小：$(du -sh "$ROOTFS_PATH" | awk '{print $1}')"
          echo "  - 完整性：xz解压测试通过"

      # 7. 上传产物到GitHub Release（确保标签唯一，避免冲突）
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 自动注入仓库令牌，无需额外配置
        with:
          # 标签格式：arm64-rootfs-发行版-版本-日期（唯一标识）
          tag_name: arm64-rootfs-${{ matrix.name }}-${{ matrix.release }}-${{ format('{0:YYYYMMdd}', github.run_started_at) }}
          # 发布名称：包含发行版、版本、日期（易读）
          release_name: "arm64 RootFS | ${{ matrix.name }} ${{ matrix.release }} (${{ format('{0:YYYY-MM-dd}', github.run_started_at) }})"
          draft: false  # 直接发布，不存草稿
          prerelease: false  # 标记为正式版本

      - name: Upload RootFS to Release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}  # 从创建Release步骤获取上传地址
          asset_path: ./${{ env.ROOTFS_NAME }}  # 产物路径
          asset_name: ${{ env.ROOTFS_NAME }}  # 上传后的文件名（与本地一致）
          asset_content_type: application/x-xz  # 正确的MIME类型（xz压缩文件）
